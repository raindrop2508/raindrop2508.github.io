[{"content":"","date":"2021-08-31","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2021-08-31","externalUrl":null,"permalink":"/","section":"RainDrop","summary":"","title":"RainDrop","type":"page"},{"content":"","date":"2021-08-31","externalUrl":null,"permalink":"/posts/tech/","section":"Posts","summary":"","title":"技术","type":"posts"},{"content":"图是比树更一般的结构，由节点和边组成。根据边是否有方向分为有向图和无向图。同时在每个边上可以加入权重，代表从一个顶点到另一个顶点的代价。\n圈(Cycle):首尾顶点相同的路径。\n图的抽象数据类型 # 图的抽象数据类型主要通过邻接矩阵或邻接表来实现。\n邻接矩阵：每行每列代表图中的顶点，行列值表示节点是否相连;简单，但大多为稀疏矩阵效率低下。 邻接列表：一个列表中包含所有顶点，其中每个顶点关联一个与自身有连接的顶点的列表；存储空间紧凑高效。 词梯问题 # 目标:找到从一个单词到另一个单词之间最短的变换序列。 步骤一：将所有单词的关系表达为图 # 方法一：将所有单词之间互相比较；思路简单，但计算量大。\n方法二：创建桶，将去掉一个字母后相同的单词放入统一桶中，最后对统一桶中的单词构建边。\ndef buildGraph(wordfile): d = {} #桶 # 构建桶，并将相同的单词放入桶中 for line in wfile: word = line[:-1] for i in range(len(word)): bucket = word[:i] + \u0026#39;_\u0026#39; + word[i+1:] if bucket in d: d[bucket].append(word) else: d[bucket]=word ...... 步骤二：采用广度优先搜索(Breadth First Search)寻找所有有效路径 # BFS搜索时，在达到更远距离K+1前会找到全部距离为K的顶点。\n搜索时需要添加距离，前驱节点，颜色三个属性，并使用队列对已发现顶点进行排列。其中颜色中白色代表尚未发现，灰色代表以及发现，黑色代表已经完成探索。\n步骤三：选择最优路径 # 最后通过追溯函数即可确定最短词梯。\n骑士周游问题 # 目标：从棋盘上一个点走遍所有棋盘上的点；建建立一个没有分支的最深的深度优先树，表现为一条线性的包含所有节点的退化树。\n步骤一：构建图 # 根据马走\u0026rsquo;日\u0026rsquo;的特性设置相对位置并保证不会超过棋盘边界。之后通过遍历构建出图。\n步骤二：寻找一个路径恰好将所有节点包含所有节点且只经过一次 # 通过深度优先搜索算法(Depth First Search)实现。**DFS:沿着树的单枝尽量深入向下搜索，如果无法找到解就回溯到上一层搜索下一枝。**在骑士周游问题中每个顶点仅访问一次。\n如果沿单枝搜索至无法继续路径仍没有达到预定值（棋盘格数），就清除颜色标记递归调用函数切换至下一枝（灰色代表以及探索，白色代表未探索）。在搜索过程中使用一个栈还记录路径便于回溯。\n搜索算法的改进 # 修改遍历下一格的次序。改为具有最少合法移动目标的格子优先搜索。（启发式规则）\n通用深度优先搜索 # 有时候深度优先搜索会创建多棵树，称为\u0026quot;深度优先森林\u0026quot;。\n通用DFS算法中加入发现时间和结束时间两个属性。\n在访问一个节点时将节点设置为灰色（搜索中），并记录开始时间。对该节点连接的白色（未搜索）节点递归调用函数（深度优先向下搜索）。最后搜索完成后将节点改为黑色（搜索完成），并记录结束时间。\n图的应用 # 拓扑排序：从工作流程图（DAG图：有向无环）得到工作次序排列的算法。利用DFS实现。\n强连通分支：图G的子集C中任意两个顶点间都有路径来回，且C是具有这样性质的最大子集。图和专职图在强连通分支的数量和划分上是相同的。\n1.对图G使用DFS算法，计算每个顶点的结束时间。\n2.将图G转置使用DFS算法，以顶点结束时间倒序顺序搜索。\n3. 深度优先森林中的每一颗树就是一个强连通分支。\n最短路径：当图已知时，带权图的最短路径问题可以看作词梯问题的改进。使用Dijkstra算法实现。\nDijkstra算法:在顶点vertex类中的成员dist用于记录开始顶点到到本顶点的最短带权路径长度（权重之和），算法对图中的每个顶点迭代一次，得出从一个顶点到其余所有顶点的最短路径。【只能处理权重大于0的图】\n最小生成树\n信息广播问题：\n1.最简单解法时由广播源维护一个收听者列表，将每个消息向每个收听者发送一次。\n2.洪水解法：将每条消息在路由器间散布出去。每个路由器将消息分别转发到相邻的路由器和收听者，并加入TTL（消息源到收听者的最远距离）。\n3.最小权重生成树。生成树：拥有图中所有顶点和最小数量的边，以保持连通的子图。使用Prim算法，每部都沿着最小权重的边向前搜索实现。\n引用 # 数据结构与算法Python版_中国大学MOOC(慕课) ","date":"2021-08-31","externalUrl":null,"permalink":"/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B07/","section":"Posts","summary":"","title":"算法笔记7-图","type":"posts"},{"content":" 非线性数据结构； 包括根，枝，叶三部分；也可以说由节点(node)和边(edge)组成； 层次化，各个子节点之间独立每个叶节点具有唯一性； 树中所有节点的最大曾经称为树的高度根节点所在的层级为0。 树的实现 # 嵌套列表实现 # 子树结构与树相同，是一种递归数据结构。\natree=['a',['left',[],[]],['right',[],[]]]\n插入方法的实现(以插入左树为例)。\ndef insertLeft(root,newBranch): t = root.pop(1) #提取左子节点 if len(t) \u0026gt; 1: #如果左子节点存在，则需要先插入新节点再将原来的节点作为其左子节点 root.insert(1,[newBranch,t,[]]) else: root.insert(1,[newBranch,[],[]]) 树的链表实现 # 节点链表法：链表中每个节点保存节点的数据项以及左右子树的链接。 插入方法：加入中间变量，将插入节点与原先节点相连接。\n应用 # 树表示表达式 树的遍历(Tree Traversals) # 遍历(Traversals)：对数据集中所有数据进行访问。对于线性数据结构，按顺序访问即可。\n树的遍历包括：前序遍历（根\u0026ndash;左\u0026ndash;右），中序遍历（左\u0026ndash;根\u0026ndash;右）和后序遍历（左\u0026ndash;右\u0026ndash;根）。\n优先队列与二叉堆 # 优先队列：先入先出，内部次序由优先级确定\n二叉堆（Binary Heap）实现优先队列 # 入队和出队的复杂度均为O（log n）。如果使操作始终保持再对数量级上，二叉树必须保持平衡。可以通过完全二叉树近似实现平衡。\n完全二叉树：叶节点最多只出现在最底层和次底层；最底层的叶节点集中在左边（最多由有一个节点例外）。\n性质：若节点下表为p,则其左子节点下标为2p，右子节点下标为2p+1。所以可以使用非嵌套列表表示完全二叉树。\n堆次序（Heap Order）：父节点的key小于其子节点。\n二叉堆 # 二叉堆的性质：\n完全二叉树：可以用非嵌套数组表示 堆：任意路径为有序数列。 二叉堆操作的实现 # 列表保存堆数据，列表中下标为0项不用。\nclass BinHeap: def __init__(): self.heapList = [0] self.currentsize = 0 insert（key）\n为了保证二叉堆中堆的性质，需要将插入key上浮至正确的位置。插入时先添加到末尾并改变二叉树currentsize的值，之后进行上浮操作。\n#上浮(i 二叉树节点数) def perUp(self,i): while i // 2 \u0026gt; 0: #到根节点j结束循环 #与父节点比较 if self.heapList[i] \u0026lt; self.heapList[i//2]: #与父节点交换位置 i = i // 2 delMin()\n删除堆中最小的key，即根节点。最后一个节点代替根节点并下沉。\n# 下沉 def percDown(self,i): # 是否存在左节点 while (i * 2) \u0026lt;= self.currentSize: mc = self.minChild(i) # 返回子节点的较小值的位置 if self.heapList[i] \u0026gt; self.heapList[mc]: # 交换下沉 ...... i = mc buildHeap(lst)\n利用下沉法从无序表生成堆。从最后一个节点的父节点处开始下沉（len(list)//2处），并不断迭代；为保证完全二叉树的性质，需要在无序表前端插入一个空值。\n二叉查找树（Binary Search Tree） # 二叉查找树比父节点大key的在右子树，比父节点小的key在左子树。\n二叉搜索树的实现 # put(key,val)\n插入key构造BST。若无节点直接将插入节点作为根节点否则调用函数_put(key,val,root)来放至key。在该辅助函数中，若key比当前节点小，则放到左子树；若比当前节点大则放到右子树。索引赋值与插入方法相同，对于此类特殊方法需要前后加双下划线。\n二叉树是一种动态查找表。特点是，树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时再进行插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。\nget(self,key)\n若根节点不存在返回空值，否则调用调用函数_get(self,key,currentNode)。在该函数中若找当对应的key则返回，否则比较key与树中key的大小，对其左、右子树递归调用函数。\n迭代器__iter__(self)\ndef __iter__(self): if self: if self.hasLeftChild(): for elem in self.leftChild: # in在这里相当于递归 yield elem yield self.key ...... delete(self,key) 先用_get方法找到要删除的节点之后执行删除self.remove(nodeToRemove)。删除节点时的情况：\n该节点无子节点（叶节点）\u0026mdash;直接执行删除。 该节点有一个子节点\u0026mdash;删除后将其子节点与其父节点连接，并对“删除节点是父节点的左/右节点？删除节点唯一子节点是其左/右节点？被删节点为根节点？”进行讨论。 该节点有两个子节点\u0026mdash;将被删节点右子树最小的节点（根据BST的性质该节点有右子节点或为叶节点）替换被删节点。 二叉查找树的性能受到插入顺序的影响。\n平衡二叉树（AVL Tree） # 在实现过程中，与 BST差别在于需要对每个节点加入平衡因子。平衡因子是左右子树的高度差，大于0为左重，小于0为右重。平衡树的每个节点的平衡因子在-1到1之间。AVL树的搜索时间复杂度为O（log n）。\n在插入方法中需要接入更新平衡因子的函数，自下而上更新每个节点的平衡因子。\n重新平衡 # 将不平衡的子树进行旋转实现，左重右旋，右重左旋，左旋挂右，右旋挂左。在旋转过程中，只有新根节点和就根节点的平衡因子发生了变化。\ndef rotateLeft(self,rotRoot): newRoot = rotRoot.rightChild rotRoot.rightChild = newRoot.leftChild # 新根左子节点，挂到旧根的右子节点,父与子相连。左旋挂右。 if newRoot.leftChild != None: newRoot.leftChild.parent = rotRoot # 子与父相连 ... ... # 整理节点之间关系 ... ... rotRoot.blanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor,0) newRoot.blanceFactor = newRoot.balanceFactor + 1 + max(newRoot.balanceFactor,0) 在左旋要检查右子节点的因子，若右子节点左重则应先右旋在左旋。同样，右旋也需要进行类似操作。\n引用 # 数据结构与算法Python版_中国大学MOOC(慕课) ","date":"2021-08-31","externalUrl":null,"permalink":"/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B06/","section":"Posts","summary":"","title":"算法笔记6-树","type":"posts"},{"content":" 查找 # 线性（顺序）关系：数据项保存在列表这样的集合中。\n顺序查找：按照顺序来访问和查找数据项；针对无序表当所要找的数据不在表中时查找需要遍历整个列表，而对于有序表可以设置一个提前结束标志减少计算量。但无论是有序表还是无序表其算法复杂度都为O(n)。\n二分查找（binary search）：对于有序表可以从中间项开始匹配，不断缩小表的规模知道找到数据的位置。二分查找法也体现了分治算法。因此二分查找法可以用递归实现。算法复杂度为O(log n)。\ndef binarySearch(alist,item): #二分查找的递归实现 ...... midpoint = len(alist)//2 if alist[midpoint]==item: return True else: #减小规模，调用自身 if item \u0026lt;alist[midpoint]: return binarySearch(alist[:midpoint],item) else: return binarySearch(alist[midpoint+1:],item) 对于两种查找算法，需要根据实际的应用情况进行选择。\n排序 # 冒泡排序（bubble sort）:两两相邻的数据进行比较，多趟之后即可完成排序。与在c语言中交换两个位置的值需要中间变量不同，python中可以使用alist[i],alist[i+1]=alist[i+1],alist[i]语句完成。算法每趟的比较次数由n-1不断递减，因此算法复杂度为O(n^2)。\n冒泡排序常作为其他算法的对比基准（妥妥的工具人🙃），其中的对次比对交换操作时无效的。优势在于无需额外储存空间的开销。\n改进的冒泡排序：当某次比对未发生交换，便说明比对完成，可以提前结束。\ndef shortBubbleSort(alist): ...... exchange = False for i in range(passnum): if alist[i]\u0026gt;alist[i+1]: exchange = True alist[i],alist[i+1]=alist[i+1],alist[i] passnum = passnum-1 选择排序(Selection Sort)：对冒泡算法中,每趟只进行一次交换。先记录最大项所在的位置再交换。\n插入排序（Insertion Sort）:复杂度仍为O(n^2);是中唯持一个已排好序的子列表，其位置始终在列表的前部。并将其逐步扩大只全表。列表越接近有序，插入排序的对比次数就越少。\ndef insertionSort(alist): ...... while position \u0026gt; 0 and alist[position-1]\u0026gt;currentvalue: alist[position]=alist[position-1] position = position - 1 #每次与左侧的项进行比较，如果左侧的值大就将其右移，依次循环直到左侧值更小，在之前的空位中插入。 alist[position]=currentvalue 谢尔排序（Shell Sort）:以“间隔”划分子列表，每个子列表执行插入排序，从而减少整体排序对比的次数。最后再进行标准的插入排序。减少了插入排序中无效的比对，介于O(n)于O(n^2)之间。\n分治思想的排序算法 # 归并排序（Merge Sort）：不断将数据表分裂为原来的一半，直到表中仅有一个数据项。之后再从最小规模开始排序（两个列表中小的先放，迭代，最后归并剩余项）直到完成这个列表的排序。\n总体来说分为分裂和归并两个过程，算法复杂度分别为O(log n)和O(n)。但会占用更多的储存空间。\n快速排序（Quick Sort）:依据“中值”将数据项分为两半，排序。不断分解至仅有一个数据项。算法复杂度取决于“中值”选取的情况，综合为O(log n)，但不需要额外的储存空间。“中值”选取中很难取得列表中准确的中值（真要准确的中值不还得排序😐），因此只能尽可能通过各种方法使选取的值与“中值”接近。\n分裂方法：左标向右移动，直到遇到比中值大的左标；同时右标向右移动，直到遇到比中值小的。将左右标指向的值交换并继续向前移动。当左标到达右标的右侧，右标所指位置即为“中值”。\n散列（Hashing） # 散列可以使查找算法的复杂度降到O(1)，散列表(hash table)包含用来储存数据的槽(slot)以及槽对应的唯一的名称。槽被数据项占据的比例称为负载因子。\n数据与槽名称通过散列函数来对应。可以通过除余数来实现槽号与槽数据项的对应，但当要存储的两个数字余数相同时便会产生冲突。\n如果一个散列函数能不会造成冲突便称之为完美散列函数。完美散列函数可以用于数据校验。将散列值看作槽中信息的摘要，由于该摘要具有唯一性因此可以通过摘要对比信息的异同。要具备数据校验的函数应具有以下特性；压缩性、易计算性、抗修改性和抗冲突性。\n近似完美散列函数MD5,SHA。\n区块链 # 区块链是一种分布式数据库，具有去中心化的特点。区块链由区块(block)组成。每个区块中包含着头(head)和体(body)。头中记录着一些元数据和链接到前一个区块的信息（生成时间、前一个区块的散列值）。\n区块链具有不可修改性。由于区块链的分布式的性质，同步速度较慢因此新区快的添加速度被限制。\nPS:每次虚拟货币涨的时候，硬件价格便会水涨船高，加上黄牛党的推波助澜，DIY玩家苦不堪言。\n散列函数的设计 # 折叠法：对数据分段、相加、求余得到槽号。通过哥数反转的方法进行微调。 平方取中法：数据平方、取中间两位、求余（相比折叠法，计算量提高）。 特殊情况\n- 对于非数项可通过ASCⅡ表进行转换。 - 对于变为词，加入权重因子\n散列函数在设计时盈尽量简单并减少冲突。\n冲突解决方案 # 再找一个空槽放置冲突数据（开放定址、再散列）。\n线性探测：向后逐个寻找空槽，查找时顺序查找。缺点：有聚集趋势。 跳跃式探测；选择固定步长或逐步变化进行探测。固定步长取值时不能被散列表大小整除，否则会产生周期。 数据项链：槽扩展为容纳数据项的集合。这会延长查找的时间\n引用 # 数据结构与算法Python版_中国大学MOOC(慕课) ","date":"2021-06-18","externalUrl":null,"permalink":"/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B05/","section":"Posts","summary":"","title":"算法笔记5_排序与查找","type":"posts"},{"content":" 开头的碎碎念 # 个人认为，递归算法是一种十分优美的算法。它总是能够用十分短小的代码长度来解决许多复杂的问题。前端实际，在看快速傅里叶变换(FFT)时，看到递归算法仅用极小的代码量即可实现复杂的理论，内心感到十分的震撼。\n将一个分问题不断拆分成更小的相同问题，其在算法上的特点就是调用自身。\n结束条件 减小规模 调用自身 递归调用的实现：函数每次调用将现场数据压入系统调用栈，当函数返回时则从栈顶返回恢复现场。\n现场数据：栈保存的一个函数调用所需要维护的信息。\n每次调用，压入栈的现场数据成为栈帧。\n#python中递归深度的设置(默认为1000) import sys sys.getrecursionlimit() sys.setrecursion(3000) 递归的应用 # 递归数列求和：将问题拆分成两个数相加，当列表长度为1时结束。 0-16任意进制的转换：设置convertstring = \u0026quot;0123456789ABCDEF\u0026quot; 通过除以整除\\\\进制基base以及对进制基求余数来将整数拆开。当数小于进制基时结束。 convertstring = \u0026#34;0123456789ABCDEF\u0026#34; ...... else: return toStr(n//base,base) + convertstring[n%base] #字符串连接；n//base表示整除 迷宫：在原位置先向北走一步，如果找不到出口则按北南西东的顺序尝试。（这个实际上随意设置也行）；为了防止艳茹无限递归的死循环，需要加入之前的路径。\n找零兑换：求兑换最少数量的硬币\n贪心策略：从允许最多数量最大面值的硬币开始，余额则用下一最大面值硬币尽可能多的数量分解。由此直到到达最小面值或余额为0。为了减少算法中的重复计算，可以将中间结果保存在表中。递归之前查表，直接返回。 2.动态规划法 动态规划 # 动态规划：从问题的最小规模的最优解开始，逐步扩大问题规模到要解决的问题。\n最优化问题能用动态规划解决的必要条件：问题最优解包含和更小规模子问题的最优解。\n递归可视化 # 分形树，谢尔宾斯基三角形，汉诺塔\n引用 # 数据结构与算法Python版_中国大学MOOC(慕课) ","date":"2021-05-04","externalUrl":null,"permalink":"/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B04/","section":"Posts","summary":"","title":"算法笔记4_递归Recursion","type":"posts"},{"content":" 队列(queue) # 队列的特征：先进先出（FIFO）\n队列仅有一个入口和出口。添加数据处为尾端，移除数据处为首端。\n队列的操作\n如果将list的首端作为队列尾端，list的末端作为队列的首端。enqueue()的复杂度为O(n),dequeue()的复杂度为O(1)。\n首位倒过来时复杂度也倒过来\n双端队列（deque）:队首和队尾都可以进行加入和移出操作。\n无序表(unordered list) # 数据的排列不具有顺序性，仅依靠相对位置\n利用链表实现无序表 # 链表的每个节点至少包含：数据项本身，下一节点的引用信息\n通过在数据项之间建立链接指向，就可以保持其前后相对位置。 通过链表实现的无序表仅仅包含对于受节点head的引用。\n添加(add)：将新的数据项添加至表头，减少算法复杂度。\ntemp.setNext(self.head) self.head = temp #以上两条语句不能交换位置 链表的查找(search)和长度(size)方法都使用遍历的思想。删除(remove)第n的节点时需要把第n-1个节点指向n+1个节点。因此，要实现该方法需要引用当前节点和上一节点。\n有序表(ordered list) # 依照某种可比性，决定列表个元素的排序\n对于python，可以适用于所有定义了__gt__方法的数据类型\n查找(search)方法：当遍历到的数据项大于所要查找的数据项，则说明所要查找的元素在链表中不存在。\n添加(add)方法：需要引用当前节点和上一节点，将新的元素加入到两者之间。\n引用 # 数据结构与算法Python版_中国大学MOOC(慕课) ","date":"2021-03-31","externalUrl":null,"permalink":"/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B03/","section":"Posts","summary":"","title":"算法笔记3","type":"posts"},{"content":" 基本数据结构 # 线性结构（linear structure） # 有序数据项的集合 每个数据项都有唯一的前驱和后继（第一个和最后一个除外） 根据数据项增减的方式构成了数据结构\n栈(Stack)\u0026ndash;仅在表尾进行插入和删除操作的线性表 队列(Queue)\u0026ndash;只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作 双端队列(Deque)\u0026ndash;限定插入和删除操作在表的两端进行的线性表 列表(List)\u0026ndash; 栈 # 进行操作的一端为栈顶，另一端为栈底\n栈的特点：后进先出LIFO\n栈通过python的实现可以借助list的数据类型\n栈的应用 # 括号匹配\u0026ndash;基本思路 # 括号匹配与之前图灵机的模型有些相似；\n括号匹配可以用用于爬虫HTML数据的爬取；另外该方法也可通过正则表达式实现。 十进制与二进制的转换 # 十进制转换二进制是余数的连续求取，并将求得的余数倒过来书写。通过栈后进先出的特性可以实现。\n同时由此可以进行十进制到其他进制的转换。当转换的进制为十一禁进制以上时，可以使用数组来保存其中的字母\ndigits = \u0026#34;0123456789ABC\u0026#34; 表达式转换 # 根据表达式操作符的的位置分为中缀、前缀和后缀，距离操作数最近的操作符先执行\n中缀表达式转换为前缀和后缀表达式\n将表达式转换为全括号形式，将内部每个运算符移到对应的左括号或右括号处边可以转换为前缀、后缀表达式\n中缀转后缀算法\n从左到右扫描过程中，采用栈来暂存为处理的操作符，当遇到一个新的操作符，就需要跟栈顶的操作符比较下优先级，再行处理。\n算法流程\n从左到右扫描\n- 当遇到操作数，直接输出至列表末尾\n- 当遇到左括号压入栈顶\n- 当遇到右括号，反复弹出栈顶加入至输出列表末尾，直到碰到左括号\n- 当遇到操作符，与栈顶其他操作符比较。栈顶操作符高于或等于它，则将输出栈顶的操作符直到优先级低于它\n后缀表达式的求值 # 后缀表达式的操作符在操作数的后面，因此要暂存操作数,直到碰到操作符才进行运算(从这可以利用栈的特性)\n在实际运算时，先弹出的时右操作数然后才是左操作数，对于‘-’和‘/’要注意两个操作数的位置\n算法流程\n创建空栈用于暂存操作数\n从左到右扫面单词列表\n如果是操作数，压入栈顶 如果是操作符，从栈顶弹出两个操作数，进行计算。（注意操作数的位置） 最后扫描结束后，表达式的值被存在栈顶（如果表达式正确，则栈中仅有最后的结果一个元素）\n引用 # 数据结构与算法Python版_中国大学MOOC(慕课) ","date":"2021-01-04","externalUrl":null,"permalink":"/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B02/","section":"Posts","summary":"","title":"算法笔记2","type":"posts"},{"content":" 算法分析 # 算法和算法复杂性 # 可计算的问题：\nwhat：分类问题——树状判定分支 why： 证明问题——公式序列解决 how： 或称问题——算法流程解决 欧几里得算法的python实现\ndef alg(a,b): if b==0 : return a print(a) c=a%b alg(b,c) def main(): #a,b为要计算的两个数 a=15 b=9 print(alg(a,b)) main() 计算复杂性研究的是问题的难度，算法实在资源约束的情况下寻找最优方案。\n不可计算问题\n停机问题 几乎所有无理数都无法通过算法找出任意一位精确数 程序与算法的区别 # 算法是描述问题解决的分布步骤而程序则是通过某种编程语言实现的算法。\n算法分析主要是从计算机资源消耗的角度来评判和比较算法。评判的两个标准有两种：算法执行时间和空间（内存或存储空间）。\n利用python的time库中 time.time()函数可以计算算法的执行时间。\ntime.time() 是计算从1970到现在的时长，并将值返回。\n对于算法运行时间的检测也收到语言性能、机器的性能的影响。\n大O表示法 # 一个算法所实施的操作数量或步骤可作为独立于程序/机器的度量指标。\n程序设计语言中除与计算资源无关的定义语句外，主要是三种控制流语句和赋值语句。\n一个赋值语句包含了（表达式）计算和（变量）存储两个基本资源。而控制流语句仅起组织语句的作用，并不涉及处理。\n算法分析的目标是找出问题规模如何影响执行时间\n数量级函数 # 数量级函数描述了T（n）中随着n增加而增加速度最快的主导部分。称作大O表示法记作O(f(n)),其中f(n)表示T(n)中的主导部分。\nT(n)=5n^2+27n+1005\n当n越来越大起主导作用的是5*n^2,其中系数5对n^2的增长速度无影响。因此可以表示为O(n^2)\n具体数据也会影响算法运行时间，如排序算法。此时分为最好，最差和平均状况，主要还是通过平均状况分析性能。\n大O表示所有上限中最小的那个上限\n大Ω表示所有下限中最大的那个下限\n如果上下限相同用Θ大表示\n变位词 # 写一个布尔函数，一两个此作为参数，返回两个词是否为变位词\n将每一个单词逐个检查 课程给的代码示例：\ndef solu1_example(s1,s2): alist = list(s2) pos1 = 0 stillok = True while pos1 \u0026lt; len(s1) and stillok: #只要字符中有一个没找到就可以通过32行退出 pos2 = 0 found =False while pos2 \u0026lt; len(alist) and not found: if s1[pos2] == alist[pos2]: found = True else: pos2 = pos2 + 1 if found: alist[pos2] = None else: stillok = False pos1 = pos1 + 1 return stillok 如果将自己一个一个对比，要注意同一个字符在字符串中可能会出现很多次。因此，在判断是找到一个相同时必须要设置为none\n数量级的计算 # 两层循环，外层循环为n次，每次到内层每次循环查找次数为1\u0026ndash;n之间。因此总和为：1/2*(n^2)+1/2*n。所以数量级为O(n^2)\n排序比较：先将字符串按字母顺序排好，再一一对比 def solu2(s1,s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() #列表排序函数 alist2.sort() pos=0 matches = True while pos \u0026lt; len(s1) and matches: if alist1[pos] == alist2[pos]: pos = pos + 1 else: matches = False return matches 看似很简单仅有一个循环，但在两个数组排序过程消耗的时间不可忽视。时间运算数量级为O(nlog n)\n暴力法 # 将S1中的字符进行全排列，然后查看S2是否在其中。\n用暴力算法解决时，数量级会以N!的方式增长。\n计数比较 # 检查26个字母在字符中出现的情况，若两者相同则输出。\nord()函数：返回字符的Unicode编码值\nT(n)=2n + 26;\n因此数量级为O(n);相比之下，该项算法性能较优，然而该算法需要的内存空间较大。\ndef solu4(s1,s2): c1 = [0] * 26 c2 = [0] * 26 for i in range(len(s1)): pos = ord(s1[i]) - ord(\u0026#39;a\u0026#39;) #返回一个字符的uincode编码 c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i]) - ord(\u0026#39;a\u0026#39;) c2[pos] = c2[pos] + 1 j = 0 stillok = True while j \u0026lt; 26 and stillok: if c1[j] == c2[j]: j = j + 1 else: stillok = False return stillok Python数据类型的性能 # list和dict # 按索引取值和赋值：由于列表的随机访问特性，均为O(1)\n列表添加append()和_add_()\u0026quot;+\u0026quot;\nlist.append(v)\u0026ndash;O(1),lst= lst+ [v] 实行时间为O(n+k),k为所加列表长度 pop的复杂度 # 从尾部移除数组的元素是复杂度为O(1),移除数组中某一元素为O(N)；原因是移除中间元素需要将这个元素后面的元素前移。这是为了保证按索引取值和赋值速度的妥协。\n在列表中in操作复杂度为O(N),字典中为O(1)。\n引用 # 数据结构与算法Python版_中国大学MOOC(慕课) ","date":"2021-01-04","externalUrl":null,"permalink":"/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/","section":"Posts","summary":"","title":"算法笔记1","type":"posts"},{"content":" 抽象数据类型（ADT） # 是对数据进行处理的一种逻辑描述，并不设计如何实现这些处理。\n递归 # 编写递归代码要注意的三点：\n递归总有一个最简单的情况\u0026mdash;方法的第一条语句总是包含 return 的条件语句。 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。 递归调用的父问题和尝试解决的子问题之间不应该有交集。 ","date":"2021-01-04","externalUrl":null,"permalink":"/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B00/","section":"Posts","summary":"","title":"算法笔记0","type":"posts"},{"content":"王小波的书读起来都不是那么的晦涩难懂，但读着读着却好像抓住了一些隐晦的道理，这些看似简单但有耐人寻味。\n这本书越是读到后面越是感觉的一丝丝凄凉。红拂，卫公，王二放荡不羁，心中有着一个诗意的世界。都以为自己可以挣脱一切束缚，却不知早已掉进更大的陷阱中去。卫公和红拂跳出了洛阳城，却又困在长安城中再也无法离开。而和人糟心的是，这是卫公亲手打造的长安城。书中说，这就好比把自己当成猪一样，自己还给自己造了围栏。\n这不禁让我想起:曾经，我天真地以为进入初中，高中，大学，社会就会过得更自由，可以做自己想做的事。但到最后连能体面地活下去都是奢望了。不曾想自己早已变成了那万众韭菜中的一抹绿。 于是，我才明白。人生就像俄罗斯套娃一样，而我一直是在最里面那层。随着你不断的长大，你回发现那束缚一层一层，无穷无尽。即使你能够傲视群雄，仍不能放浪形骸。\n这个世界许多时候真的太糟糕了，甚至各种匪夷所思的事情在各地轮番上演，比任何小说都魔幻。书中的话”一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。”对我来说更像是一种安慰，在世界上唯一能让自己无拘无束的，还是心中的那个世界啊。\n","date":"2021-01-04","externalUrl":null,"permalink":"/posts/other/hongfu/","section":"Posts","summary":"","title":"《红拂夜奔》","type":"posts"},{"content":"","date":"2021-01-04","externalUrl":null,"permalink":"/posts/other/","section":"Posts","summary":"","title":"其他","type":"posts"},{"content":"清晨，街道;\n单车，外套。\n家中的黑猫，\n不辞而别。\n我拼命的寻找，\n却仿佛从未出现。\n","date":"2021-01-04","externalUrl":null,"permalink":"/posts/other/%E9%9B%BE/","section":"Posts","summary":"","title":"雾","type":"posts"},{"content":"期待与你联系\n关于博客 # 19年使用Github + Hexo搭建的博客，20年底的时候换了一次主题。 21年开始使用服务器域名的形式完成了第二版，后来域名到期，放弃之。 25年左右使用 xlog 搭建了第三版，但 xlog 似乎出现了问题，GG。 26年开始使用 Hugo 搭建了第四版，在此归来。希望这次是最后一次。 ","date":"2021-01-04","externalUrl":null,"permalink":"/about/about/","section":"Abouts","summary":"","title":"About","type":"about"},{"content":"","date":"2021-01-04","externalUrl":null,"permalink":"/about/","section":"Abouts","summary":"","title":"Abouts","type":"about"},{"content":" yolov3学习笔记 # 基本概念 # 下采样即图像缩小；将x*x个像素点取均值换算为一个。\n上采样即图像放大，利用插值算法。\nground truth即监督学习中数据标注的正确的范围。也就是标准答案的意思。\nIOU预测的范围（bounding box）与ground truth的交集/两者并集\nbounding box(bbox) 在目标检测中不仅要知道目标的类别还要知道它的位置。在木变检测中常用边界框来描述目标位置。\nanchor box目标检测算法通常会在输入图像中采样大量的区域，然后判断这些区域中是否包含我们感兴趣的目标，并调整区域边缘从而更准确地预测目标的真实边界框（ground-truth bounding box）。不同的模型使用的区域采样方法可能不同。这里我们介绍其中的一种方法：它以每个像素为中心生成多个大小和宽高比（aspect ratio）不同的边界框。这些边界框被称为锚框（anchor box）。(——动手做深度学习)\n精确率与召回率实际上非常简单，精确率是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是真正的正样本。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)，也就是\nP=TP/(TP+FP)\n而召回率是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)。\nR=TP/TP+FN\n非极大值抑制简称为NMS算法，思想是搜索局部最大值，抑制极大值。\n流程如下：\n根据置信度得分进行排序\n选择置信度最高的比边界框添加到最终输出列表中，将其从边界框列表中删除\n计算所有边界框的面积\n计算置信度最高的边界框与其它候选框的IoU。\n删除IoU大于阈值的边界框\n重复上述过程，直至边界框列表为空。\n**批标准化(batch normalization)**将分散的数据统一的做法，便与神经网络的学习和优化。normalization 预处理, 使得输入的 x 变化范围不会太大, 让输入值经过激励函数的敏感部分。BN实在每个全连接层之间都进行批数据标准化。(作者： 聚类算法 # 聚类算法是根据样本之间的距离来将他们归为一类的，这个距离不是普通的距离，理论上叫做欧氏距离。\n一般面向大量的，同时维度在2个或两个以上的样本群。\n1、在样本中随机选择K个点，作为每个类别的初始中心点，这K是自己定的，假如你想将样本分成3个类K就等于3,4个类K就等于4；\n2、计算所有样本离这K个初始中心点的距离并分别进行比较，选出其中最近的距离并把这个样本归到这个初始中心点的类别里，即总共划分成K个类别；\n3、舍弃原来的初始中心点，在划分好的K个类别里分别计算出新的中心点，使得这些中心点距离他类别里的所有样本的距离之和最小；\n4、判断新获得的中心点是否与旧中心点一样，如不一样则回到第2步，重新计算所有样本离这K个新的中心点的距离并进行比较，选出其中最近的距离并归到这个新的中心点的类别里，继续下面的步奏；如一样则完成，即收敛。\n残差网络 # 残差 # 残差：实际观测值与估计值（拟合值）之间的差。如果回归模型正确则残差可以看做误差的观测值。\n理论上，可以训练一个 shallower 网络，然后在这个训练好的 shallower 网络上堆几层 identity mapping（恒等映射） 的层，即输出等于输入的层，构建出一个 deeper 网络。这两个网络（shallower 和 deeper）得到的结果应该是一模一样的.\n退化问题 # 为什么属于随着层数的增多训练集上的效果变差？\n原因是随着网络越来越深，训练变得原来越难，网络的优化变得越来越难。理论上，越深的网络，效果应该更好；但实际上，由于训练难度，过深的网络会产生退化问题，效果反而不如相对较浅的网络。而残差网络就可以解决这个问题的，残差网络越深，训练集上的效果会越好。（测试集上的效果可能涉及过拟合问题。过拟合问题指的是测试集上的效果和训练集上的效果之间有差距。）这里要注意到过拟合与退化问题之间的区别\n残差块 # 残差网络是通过加入shortcut connections,变得更容易被优化。包含一个shortcut connection的几层网络被称为一个残差块。shortcut即图中x到 ⨁的箭头。\n残差块（residual block） # 𝑥 表示输入，𝐹(𝑥) 表示残差块在第二层激活函数之前的输出，即 𝐹(𝑥)=𝑊2𝜎(𝑊1𝑥)，其中 𝑊1 和 𝑊2 表示第一层和第二层的权重，𝜎 表示 ReLU 激活函数。（这里省略了 bias。）最后残差块的输出是 𝜎(𝐹(𝑥)+𝑥)。\n激活函数：上层节点的输出与下层节点的输入之间的函数关系。\n常用的激活函数有：sigmoid函数，tanh函数，relu函数（这个比较常用）\u0026hellip; \u0026hellip;\n残差块中的网络可以使全连接层也可以是卷积层。\n设第二层网络在激活函数之前的输出为 𝐻(𝑥)。如果在该 2 层网络中，最优的输出就是输入 𝑥，那么对于没有 shortcut connection 的网络，就需要将其优化成 𝐻(𝑥)=𝑥；对于有 shortcut connection 的网络，即残差块，最优输出是 𝑥，则只需要将 𝐹(𝑥)=𝐻(𝑥)−𝑥 优化为 0 即可。后者的优化会比前者简单。这也是残差这一叫法的由来。\n上面相当于优化了恒等映射。残差网络可以不是神经网络，用全连接层也可以。\n为什么残差网络会work # 我们给一个网络不论在中间还是末尾加上一个残差块，并给残差块中的 weights 加上 L2 regularization（weight decay），这样图 1 中 𝐹(𝑥)=0 是很容易的。这种情况下加上一个残差块和不加之前的效果会是一样，所以加上残差块不会使得效果变得差。如果残差块中的隐藏单元学到了一些有用信息，那么它可能比 identity mapping（即 𝐹(𝑥)=0）表现的更好。\n边界框回归 # 对于窗口一般使用四维向量(x,y,w,h) 来表示， 分别表示窗口的中心点坐标和宽高。 对于图 2, 红色的框 P 代表原始的Proposal, 绿色的框 G 代表目标的 Ground Truth， 我们的目标是寻找一种关系使得输入原始的窗口 P 经过映射得到一个跟真实窗口 G 更接近的回归窗口Ĝ。\n边框回归的目的既是：给定(Px,Py,Pw,Ph)(Px,Py,Pw,Ph)寻找一种映射ff， 使得f(Px,Py,Pw,Ph)=(Gx^,Gy^,Gw^,Gh^)f(Px,Py,Pw,Ph)=(Gx^,Gy^,Gw^,Gh^) 并且(Gx^,Gy^,Gw^,Gh^)≈(Gx,Gy,Gw,Gh)\n边框回归的方法：平移+尺度缩放\nyolov1-yolov3 # yolov1 # 检测处理理想 # 将输入图片划分为S * S的格子（逻辑区域），如果物体的中心坐标落在某个格子中，那么这个格子就负责检测这个物体（包括bounding box的坐标和类别概率）。每个格子预测B个bounding boxes和B个置信度，这个置信度表示这个格子预测的bounding boxes包含物体的可信程度，论文作者将置信度定义为 Pr(Object)* IOU。Pr(Object)的值为0或者1，表示存不存在目标物体。\n每一个bounding box包括五个元素，x，y，w，h，confidence。坐标(x，y)表示的是box的中心坐标，并且是相对于格子的边界而言，w和h也是相对于整张图片的宽度和高度而言。置信度预测的值表示预测框和真实框的IOU值。虽然每个格子预测B个bounding box，但是每个格子只预测一组类条件概率，注意这里不是anchor，因为多个bounding box共用了一组class probability(表示的是先验概率)。所以网络架构的最后一层实际预测了B个bouding box和一组类别概率，注意这只是针对于一个格子，所以在不考虑batch size的情况下，实际预测输出长度为S* S*（B*5+C)\n训练过程 # 对于前面所说bounding box，作者也做了一些处理，将bounding box的w,h除以训练图像的宽度和高度（448*448），使其值在0-1之间。至于bouding box的x,y的实际值意义，作者认为不是相对于整张图片的中心坐标值，而是相对于的对应格子坐标左上边界偏移值，所以x,y的值也在0-1之间，这个地方有些难以理解。\n通过置信度为每一个各自从B个bounding box中筛选一个最终的bounding box。于是每个各自的坐标为（0+x，0+y），（0+x, 1+y）\u0026hellip;\u0026hellip;.\n通过我们设定的置信度阈值使用非极大值抑制方法从这49个bounding box中筛选；还有一种做法就是直接从98个bounding boxes使用非极大值抑制方法筛选。从图片的全局性来考虑，第一种方法更能体现图片的整体性。确定完bounding boxes后，用bounding box坐标值乘以与原图的比例值就可以在原图中框出相应的物体。\nyolov2 # 1.对数据进行批标准化处理。\n2.High Resolution Classifier:低分辨率训练分类网络，高分辨率训练检测网络，在两个过程见了一个适应性微调。\n3.Convolutional With Anchor Boxes（锚框卷积）：作者去掉了YOLOv1的全连接层，使用anchor boxes来预测bounding boxes，同时也去掉了最后池化层使得最后feature maps的分辨率大一些。与YOLOv1不同的是，YOLOv2为每一个bounding box预测一个类条件概率【YOLOv1中B个bounding box共用一个类条件概率】。在YOLOv1中bounding boxes数目为：S* S*(5* B+C)，而在YOLOv2中bounding box数目为S * S*B（5+C）。使用anchor box没有使精度提升，提高了召回率。\n4.作者采用维度聚类的方法对数据集的真实标签的bounding box进行聚类分析从而确定B的取值。如果用欧式距离来衡量K-means的距离，会使得大的bounding box比小的bounding box产生更大的误差，于是作者调整距离计算公式为： 5.13* 13的feature map可以提供足够信息预测较大的物体，但是对于小物体而言提供的信息仍然不够，所以作者提供了一个passthrough层，利用26*26的feature map来预测小物体（可能是受SSD的启发，不同大小的特征图检测不同大小的物体）。\n6.YOLOv2的网络只有卷积层和池化层，所以就可以在训练进行的过程改变feature maps的shape。 为了使得YOLOv2更具鲁棒性，我们让模型能够对不同大小的图片进行训练。在训练过程中，每10个batch就换一组新尺度的图片（这里的新图片指大小不同，图片的其他属性是一样的）。\n作者提出了一种将分类数据集和检测数据集联合训练的方法，在训练的过程，我们将这两类数据集混合，当输入的检测数据集时，反向传播全部的误差损失（YOLOv2的loss），当遇到分类数据集时，只反向传播分类误差损失。\nyolov3 # ###　1.边界框预测\nYOLOv3中引入一个Objectness score概念，使用logistic regression为每一个bounding box预测一个Objectness score。将预测的bounding boxes中与真实bounding box重叠最大的bounding box的Objectness score赋值为1，如果这个bounding box与真实bounding box重叠值达到设定的阈值0.5，这个bounding box的损失为0，其同一格子里面的其他bounding box只计算置信度损失，忽略坐标损失和类别损失。(可以认为0.5表示预测的边界框已经能很好地标记框出物体，所以不用计算它的损失。每一个格子中的object由一个预测的bounding box预测。既然已经找到了较好地bounding box，所以同一个格子里面的其他bounding box没有必要计算坐标误差和分类误差，只需要计算置信度误差，用来调整置信度，最理想的效果是这些bounding box的置信度值更新为0）。\n这里bounding box是指网络模型预测的confidence，bx，by，bw，bh，计算置信度误差时，用真实标签坐标和预测坐标（bx，by，bw，bh）计算IOU，Objectness score相当于Pr(Object)，所以最终的置信度计算为IOU*Pr（Object）\n2.类别预测 # 类别预测使用了多标签分类（多分类），没有使用softmax，而是对每一个类各自对立地使用了logistic分类器，用binary cross-entroy loss替代softmax loss，这样能较好地处理标签重叠（包含）关系（例如：女人和人）。\n3.交叉尺度(多尺度)预测 # YOLOv3预测三种不同尺度的box，每一种尺度预测三个anchor boxes，即NN(3*(4+1+80))，所以最终的输出是3*【NN(3*(4+1+80))】，最前面的3表示三种尺度。3种尺度，3个anchor box，是由聚类数为9决定的，按照一定的顺序（面积从小到大）将这个聚蔟box分配给不同尺度。在YOLOv2中，为了加强对小物体的检测，引入了passthrough层，假设最后提取的feature map的size是1313，passthrough层的作用是将上层2626的feature map和最后层13*13的feature map连接，作为网络最后的输出。\nYOLOv3是采用了低分辨率feature map上采用和高分辨率feature map做融合，形成新的feature map层，对新的feature map层单独做预测。这样就是多尺度预测。如果YOLOv3最后一层也是1313的话，那么三个尺度的大小为（1313，2626，5252），第三个尺度只用第二个尺度上采样并做融合。值得说明的是：YOLOv2中的多尺度指输入图像的大小不同，YOLOv3的多尺度是指用不同的分辨率的feature map做预测。\n##　参考文献：\n什么是批标准化　作者：莫烦\n聚类算法　作者：挖数\n残差网络　作者：wuliytTaotao\n边框回归(Bounding Box Regression)详解　作者：南有乔木NTU\n目标检测之YOLO系列-V1至V3改进详解　作者：xd1723138323\n","date":"2019-08-17","externalUrl":null,"permalink":"/posts/tech/yolo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%91/","section":"Posts","summary":"","title":"Yolo学习笔记＿１","type":"posts"},{"content":"这篇笔记会根据情况隔段时间更新一次\n终端操作 # cd+文件夹名 进入文件夹 可以使用TAB键进行自动补全或选择 cd ..( 退出几层就加几个..) 退出到上n层路径\nls 显示文件夹中的目录\npwd 显示当前路径\ngedit 使用文本编辑器编辑文件\ncat 在终端中查看文件（多用做文本文件）\nsudo 进入管理员模式（超级用户)\nsudo su 进入根用户\nnvidia-smi 查看显卡运行状态（A卡没有试过）\n在ubuntu中一些文件被写保护，需要更高级权限才能修改，可以在命令前加sudo\n复制一个文件到指定目录 # (1) 在桌面上打开终端，输入sudo su\n(2) 输入密码，就切换到root用户下\n(3) 切换到桌面 命令输入为 cd 桌面\n(4) 然后输入复制命令行 cp -r studio.zip /home/androidstudio\n(5) 回车 大功告成 可以看看/home/androidstudio目录下是否有studio.zip\n作者：飞奔的小付\n来源：CSDN\n原文\n移动文件（假设现在在该文件的目录下）\nsudo mv xxx.xx 新的位置的路径\n解压文件\nsudo unzip opencv-3.3.0.zip\n重命名文件\nsudo cp 原文件名 新文件名\n软件安装 # 软件安装前一般要先更新软件目录\nsudo apt-get update\n升级已有软件\nsudo apt-get upgrade 常用软件安装 https://www.jianshu.com/p/f44e1ae080a5\n下载好网易云音乐安装完成后可能会遇到问题打不开。可以在终端中使用\nsudo netease TAb(自动补全)\n当下在好软件安装包后，也可以在本地安装\nsudo sh xxx.sh\ndpkg -i xxx.deb\ngoogle浏览器安装\n踩过的坑 # 没有声音解决办法\n具体情况是：可以调节音量，但却没有声音 这个问题到现在，我仍旧是每次开机仍要打开文章中所说的软件修改一次 ubuntu和win双系统中无法访问win中的磁盘分区\nsudo ntfsfix /dev/磁盘号\n如sudo ntfsfix /dev/sda6\nubuntu中python2和3共存\nsource activate [要激活的环境名称]\nsource deactivate\n如何修复 apt-get update 无法添加新的 CD-ROM 的错误\n侵权即删\n","date":"2019-06-30","externalUrl":null,"permalink":"/posts/tech/ubuntu_note/","section":"Posts","summary":"","title":"Ubuntu笔记","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/posts/daily/","section":"Posts","summary":"","title":"日常","type":"posts"}]